import os
import time
import requests
import json
import threading
from collections import deque
import colorama
from colorama import Fore, Style, Back
from datetime import datetime
import pytz
import random

colorama.init(autoreset=True)

class EscapeMasterTool:
    def __init__(self):
        self.config_file = "config.json"
        self.lich_su_phong = deque(maxlen=20)  # L∆∞u l·ªãch s·ª≠ ph√≤ng
        self.tong_loi = 0
        self.tool_running = True
        self.vong_choi = None
        self.chuoi_thang = 0
        self.count_thang = 0
        self.count_thua = 0
        self.number_cuoc = 0
        self.current_time = int(time.time() * 1000)
        self.bet_history = []
        self.last_update_id = 0
        self.telegram_thread = None
        self.current_balance = 0
        
        # Load configuration
        self.load_config()
        
        # API endpoints
        self.url = f"https://user.3games.io/user/regist?is_cwallet=1&is_mission_setting=true&version=&time={self.current_time}"
        self.api_10_van = f"https://api.escapemaster.net/escape_game/recent_10_issues?asset=BUILD"
        self.api_cuoc = "https://api.escapemaster.net/escape_game/bet"
        
        # Headers
        self.headers = {
            "user-id": self.config["user_id"],
            "user-login": self.config["user_login"],
            "user-secret-key": self.config["user_secret_key"]
        }
        
        # Start Telegram bot in a separate thread
        if self.config["telegram_bot_token"] and self.config["telegram_chat_id"]:
            self.telegram_thread = threading.Thread(target=self.telegram_bot, daemon=True)
            self.telegram_thread.start()

    def load_config(self):
        """Load configuration from config.json or create a new one"""
        if os.path.exists(self.config_file):
            try:
                with open(self.config_file, "r") as f:
                    self.config = json.load(f)
                print(Fore.GREEN + "C·∫•u h√¨nh ƒë√£ ƒë∆∞·ª£c t·∫£i th√†nh c√¥ng t·ª´ config.json")
            except:
                print(Fore.RED + "L·ªói khi ƒë·ªçc config.json, t·∫°o c·∫•u h√¨nh m·ªõi")
                self.create_config()
        else:
            print(Fore.YELLOW + "Kh√¥ng t√¨m th·∫•y config.json, t·∫°o c·∫•u h√¨nh m·ªõi")
            self.create_config()
    
    def create_config(self):
        """Create a new configuration file"""
        self.config = {
            "user_id": input("Nh·∫≠p UID: "),
            "user_login": input("Nh·∫≠p user_login (m·∫∑c ƒë·ªãnh: login_v2): ") or "login_v2",
            "user_secret_key": input("Nh·∫≠p secret key: "),
            "initial_bet": int(input("Nh·∫≠p s·ªë ti·ªÅn c∆∞·ª£c ban ƒë·∫ßu (VD: 1): ")),
            "stop_loss_enabled": input("B·∫≠t Stop Loss? (y/n): ").lower() == 'y',
            "stop_loss_amount": 0,
            "take_profit_amount": 0,
            "multipliers": [15, 20, 15],
            "telegram_bot_token": "",
            "telegram_chat_id": ""
        }
        
        if self.config["stop_loss_enabled"]:
            self.config["stop_loss_amount"] = int(input("Nh·∫≠p s·ªë ti·ªÅn d·ª´ng l·ªó: "))
            self.config["take_profit_amount"] = int(input("Nh·∫≠p s·ªë ti·ªÅn d·ª´ng l·ªùi: "))
        
        custom = input("T√πy ch·ªânh h·ªá s·ªë g·∫•p? (y/n): ").lower()
        if custom == 'y':
            self.config["multipliers"] = [
                float(input("H·ªá s·ªë l·∫ßn 1 (VD: 15): ")),
                float(input("H·ªá s·ªë l·∫ßn 2 (VD: 20): ")),
                float(input("H·ªá s·ªë l·∫ßn 3 (VD: 15): "))
            ]
        
        telegram = input("K√≠ch ho·∫°t Telegram bot? (y/n): ").lower()
        if telegram == 'y':
            self.config["telegram_bot_token"] = input("Nh·∫≠p Telegram bot token: ")
            self.config["telegram_chat_id"] = input("Nh·∫≠p Telegram chat ID: ")
        
        with open(self.config_file, "w") as f:
            json.dump(self.config, f, indent=4)
        print(Fore.GREEN + "C·∫•u h√¨nh ƒë√£ ƒë∆∞·ª£c l∆∞u v√†o config.json")

    def clear_screen(self):
        os.system("cls" if os.name == "nt" else "clear")

    def display_header(self):
        """Display a beautiful header"""
        self.clear_screen()
        print(Fore.CYAN + Style.BRIGHT + "=" * 70)
        print(Fore.YELLOW + Style.BRIGHT + "ESCAPE MASTER TOOL - THU·∫¨T TO√ÅN G·ªêC")
        print(Fore.CYAN + Style.BRIGHT + "=" * 70)
        print(Fore.MAGENTA + f"UID: {self.config['user_id']}")
        print(Fore.MAGENTA + f"Secret Key: {self.config['user_secret_key'][:4]}...{self.config['user_secret_key'][-4:]}")
        print(Fore.CYAN + "-" * 70)

    def display_stats(self):
        """Display game statistics"""
        print(Fore.GREEN + f"Th·∫Øng: {self.count_thang} | " + 
              Fore.RED + f"Thua: {self.count_thua} | " + 
              Fore.YELLOW + f"Chu·ªói th·∫Øng: {self.chuoi_thang}")
        print(Fore.BLUE + f"T·ªïng l·ªùi/l·ªó: {self.tong_loi} BUILD")
        print(Fore.CYAN + "-" * 70)

    def login(self):
        try:
            response = requests.get(self.url, headers=self.headers)
            if response.status_code == 200:
                data = response.json()
                if data.get("code") == 200:
                    username = data["data"]["username"]
                    self.so_du_ban_dau = round(data["data"]["cwallet"]["ctoken_contribute"])
                    self.current_balance = self.so_du_ban_dau
                    print(Fore.GREEN + f"ƒêƒÉng nh·∫≠p th√†nh c√¥ng: {username}")
                    print(Fore.GREEN + f"S·ªë D∆∞: {self.so_du_ban_dau} BUILD")
                    
                    # Send login notification to Telegram
                    message = (
                        f"üöÄ *ƒêƒÉng nh·∫≠p th√†nh c√¥ng!*\n"
                        f"üë§ User: `{username}`\n"
                        f"üí∞ S·ªë d∆∞: `{self.so_du_ban_dau} BUILD`\n"
                        f"üÜî UID: `{self.config['user_id']}`"
                    )
                    self.send_telegram_message(message)
                else:
                    print(Fore.RED + "ƒêƒÉng nh·∫≠p kh√¥ng th√†nh c√¥ng")
                    self.tool_running = False
            else:
                print(Fore.RED + "L·ªói m·∫°ng khi ƒëƒÉng nh·∫≠p")
        except Exception as e:
            print(Fore.RED + f"L·ªói ƒëƒÉng nh·∫≠p: {str(e)}")

    def tong_loi_lo(self):
        try:
            response = requests.get(self.url, headers=self.headers)
            if response.status_code == 200:
                data = response.json()
                if data.get("code") == 200:
                    ctoken = round(data["data"]["cwallet"]["ctoken_contribute"])
                    self.current_balance = ctoken
                    loi_lo = ctoken - self.so_du_ban_dau
                    
                    # Check stop loss/take profit
                    if self.config["stop_loss_enabled"]:    
                        if loi_lo <= -self.config["stop_loss_amount"]:    
                            print(Fore.RED + f"ƒê·∫†T STOP LOSS: {loi_lo} BUILD. D·ª™NG TOOL!")    
                            self.tool_running = False
                            self.send_telegram_message(f"üõë *ƒê·∫†T STOP LOSS!*\nD·ª´ng tool v·ªõi l·ªó: `{loi_lo} BUILD`")
                        elif loi_lo >= self.config["take_profit_amount"]:    
                            print(Fore.GREEN + f"ƒê·∫†T TAKE PROFIT: {loi_lo} BUILD. D·ª™NG TOOL!")    
                            self.tool_running = False
                            self.send_telegram_message(f"üéØ *ƒê·∫†T TAKE PROFIT!*\nD·ª´ng tool v·ªõi l·ªùi: `{loi_lo} BUILD`")
        except Exception as e:
            print(Fore.RED + f"L·ªói ki·ªÉm tra l·ªùi/l·ªó: {str(e)}")

    def lich_su(self):
        try:
            response = requests.get(self.api_10_van, headers=self.headers)
            if response.status_code == 200:
                data = response.json()
                if data.get("code") == 0:
                    issues = data.get("data", [])[:3]
                    if not issues:
                        return
                    
                    vong_truoc = issues[0]["issue_id"]
                    room_id = issues[0]["killed_room_id"]
                    vong_hien_tai = vong_truoc + 1
                    
                    room_mapping = {
                        1: "Nh√† Kho", 2: "Ph√≤ng H·ªçp", 3: "Ph√≤ng Gi√°m ƒê·ªëc",
                        4: "Ph√≤ng Tr√≤ Chuy·ªán", 5: "Ph√≤ng Gi√°m S√°t", 6: "VƒÉn Ph√≤ng",
                        7: "Ph√≤ng T√†i V·ª•", 8: "Ph√≤ng Nh√¢n S·ª±"
                    }
                    
                    ten_phong = room_mapping.get(room_id, "Kh√¥ng x√°c ƒë·ªãnh")
                    issue_details = []
                    for issue in issues:
                        id = issue["issue_id"]
                        room = issue["killed_room_id"]
                        ten = room_mapping.get(room, "Kh√¥ng x√°c ƒë·ªãnh")
                        issue_details.append({"issue_id": id, "room": ten})
                    
                    if vong_truoc != self.vong_choi:
                        self.display_header()
                        self.display_stats()
                        
                        print(Fore.YELLOW + f"V√≤ng hi·ªán t·∫°i: #{vong_hien_tai}")
                        print(Fore.CYAN + f"K·∫øt qu·∫£ v√≤ng tr∆∞·ªõc: #{vong_truoc} | {ten_phong}")
                        print(Fore.BLUE + "L·ªãch s·ª≠ g·∫ßn nh·∫•t:")
                        for issue in issue_details:
                            print(f"  #{issue['issue_id']}: {issue['room']}")
                        
                        self.vong_choi = vong_truoc
                        self.kiem_tra_dieu_kien(issue_details)
        except Exception as e:
            print(Fore.RED + f"L·ªói l·∫•y l·ªãch s·ª≠: {str(e)}")

    def dat_cuoc(self, room_id, room_name):
        body = {
            "asset_type": "BUILD",
            "bet_amount": self.amount,
            "room_id": room_id,
            "user_id": self.config["user_id"]
        }
        
        try:
            res = requests.post(self.api_cuoc, headers=self.headers, json=body)
            if res.status_code == 200:
                data = res.json()
                if data.get("code") == 0:
                    print(Fore.GREEN + f"C∆∞·ª£c th√†nh c√¥ng {self.amount} BUILD v√†o {room_name}")
                    
                    # Record bet
                    self.bet_history.append({
                        "time": datetime.now().strftime("%H:%M:%S"),
                        "amount": self.amount,
                        "room": room_name,
                        "status": "ƒêang ch·ªù"
                    })
                    
                    # Send to Telegram
                    message = (
                        f"üéØ *ƒê·∫∑t c∆∞·ª£c th√†nh c√¥ng!*\n"
                        f"üí∞ S·ªë ti·ªÅn: `{self.amount} BUILD`\n"
                        f"üö™ Ph√≤ng: `{room_name}`\n"
                        f"‚è± Th·ªùi gian: `{datetime.now().strftime('%H:%M:%S')}`"
                    )
                    self.send_telegram_message(message)
                else:
                    print(Fore.RED + f"L·ªói c∆∞·ª£c: {data.get('message', 'Unknown error')}")
            else:
                print(Fore.RED + f"L·ªói c∆∞·ª£c: {res.status_code}")
        except Exception as e:
            print(Fore.RED + f"L·ªói c∆∞·ª£c: {str(e)}")

    def tinh_ty_le_phong(self):
        """T√≠nh t·ª∑ l·ªá an to√†n c·ªßa c√°c ph√≤ng d·ª±a tr√™n l·ªãch s·ª≠"""
        if not self.lich_su_phong:
            return {}
        
        weights, wins, total = {}, {}, {}
        for i, (room, dinh) in enumerate(reversed(self.lich_su_phong)):
            weight = 1 - (i / len(self.lich_su_phong))
            total[room] = total.get(room, 0) + weight
            if dinh:
                wins[room] = wins.get(room, 0) + weight
                
        return {room: round(wins.get(room, 0) / total[room] * 100, 1) for room in total}

    def kiem_tra_dieu_kien(self, issue_details):
        room_mapping = {
            "Nh√† Kho": 1, "Ph√≤ng H·ªçp": 2, "Ph√≤ng Gi√°m ƒê·ªëc": 3,
            "Ph√≤ng Tr√≤ Chuy·ªán": 4, "Ph√≤ng Gi√°m S√°t": 5,
            "VƒÉn Ph√≤ng": 6, "Ph√≤ng T√†i V·ª•": 7, "Ph√≤ng Nh√¢n S·ª±": 8
        }
        
        # Get last 3 rooms
        room_0 = issue_details[0]["room"]
        room_1 = issue_details[1]["room"]
        room_2 = issue_details[2]["room"]
        
        # L∆∞u k·∫øt qu·∫£ v√≤ng tr∆∞·ªõc v√†o l·ªãch s·ª≠
        dinh = (room_0 == room_2)
        self.lich_su_phong.append((room_0, dinh))
        
        # T√≠nh t·ª∑ l·ªá an to√†n c·ªßa c√°c ph√≤ng
        tile = self.tinh_ty_le_phong()
        if tile:
            print(Fore.CYAN + "T·ª∑ l·ªá an to√†n c√°c ph√≤ng:")
            for k, v in tile.items():
                print(f"  {k}: {v}%")
        
        # L·∫•y danh s√°ch c√°c ph√≤ng ƒë√£ ƒë·ªãnh trong 5 v√≤ng g·∫ßn nh·∫•t
        phong_da_dinh = [phong for phong, trung in list(self.lich_su_phong)[-5:] if trung]
        
        # S·∫Øp x·∫øp c√°c ph√≤ng theo t·ª∑ l·ªá an to√†n (t·ª´ th·∫•p ƒë·∫øn cao)
        phong_an_toan = sorted(tile.items(), key=lambda x: x[1]) if tile else []
        
        room_name = None
        room_id = None
        
        # X√°o tr·ªôn danh s√°ch ƒë·ªÉ tr√°nh ch·ªçn c√πng 1 ph√≤ng li√™n t·ª•c
        random.shuffle(phong_an_toan)
        
        # T√¨m ph√≤ng an to√†n nh·∫•t ch∆∞a ƒë·ªãnh trong 5 v√≤ng g·∫ßn nh·∫•t v√† kh√¥ng ph·∫£i ph√≤ng v·ª´a ch∆°i
        for ten_phong, _ in phong_an_toan:
            if ten_phong in room_mapping and ten_phong != room_0 and ten_phong not in phong_da_dinh:
                room_name = ten_phong
                room_id = room_mapping[ten_phong]
                break
        
        # N·∫øu kh√¥ng t√¨m th·∫•y, ch·ªçn ph√≤ng an to√†n nh·∫•t kh√¥ng ph·∫£i ph√≤ng v·ª´a ch∆°i
        if not room_id:
            for ten_phong, _ in phong_an_toan:
                if ten_phong in room_mapping and ten_phong != room_0:
                    room_name = ten_phong
                    room_id = room_mapping[ten_phong]
                    break
        
        # N·∫øu v·∫´n kh√¥ng t√¨m th·∫•y, ch·ªçn ph√≤ng ƒë·∫ßu ti√™n trong danh s√°ch
        if not room_id:
            room_name = room_1
            room_id = room_mapping.get(room_name, 1)  # Default to Nh√† Kho if not found
        
        print(Fore.YELLOW + f"\nCH·ªåN PH√íNG: {room_name} (ID: {room_id})")
        
        # X√°c ƒë·ªãnh s·ªë ti·ªÅn c∆∞·ª£c
        if self.number_cuoc == 0:
            self.amount = self.config["initial_bet"]
        else:
            thang = room_0 != room_2
            if thang:
                self.amount = self.config["initial_bet"]
            else:
                if self.number_cuoc == 1:
                    self.amount = int(self.amount * self.config["multipliers"][0])
                elif self.number_cuoc == 2:
                    self.amount = int(self.amount * self.config["multipliers"][1])
                elif self.number_cuoc == 3:
                    self.amount = int(self.amount * self.config["multipliers"][2])
                else:
                    self.amount = self.config["initial_bet"]
                    self.number_cuoc = 1
        
        # ƒê·∫∑t c∆∞·ª£c
        self.dat_cuoc(room_id, room_name)
        
        # Ki·ªÉm tra k·∫øt qu·∫£ v√† c·∫≠p nh·∫≠t tr·∫°ng th√°i
        thang = room_0 != room_2
        if thang:
            print(Fore.GREEN + "Th·∫Øng!")
            self.count_thang += 1
            self.chuoi_thang += 1
            self.tong_loi += self.amount
            self.number_cuoc = 0
            
            # Update last bet status
            if self.bet_history:
                self.bet_history[-1]["status"] = "Th·∫Øng"
        else:
            print(Fore.RED + "Thua!")
            self.count_thua += 1
            self.chuoi_thang = 0
            self.tong_loi -= self.amount
            self.number_cuoc += 1
            
            # Update last bet status
            if self.bet_history:
                self.bet_history[-1]["status"] = "Thua"
        
        self.tong_loi_lo()

    def send_telegram_message(self, message, chat_id=None):
        """Send message to Telegram"""
        if not self.config["telegram_bot_token"]:
            return
        
        # Use provided chat_id or config chat_id
        target_chat_id = chat_id or self.config["telegram_chat_id"]
        
        url = f"https://api.telegram.org/bot{self.config['telegram_bot_token']}/sendMessage"
        payload = {
            "chat_id": target_chat_id,
            "text": message,
            "parse_mode": "Markdown"
        }
        
        try:
            requests.post(url, json=payload)
        except Exception as e:
            print(Fore.RED + f"L·ªói g·ª≠i Telegram: {str(e)}")

    def telegram_bot(self):
        """Telegram bot to handle commands"""
        print(Fore.GREEN + "Telegram bot ƒë√£ kh·ªüi ƒë·ªông...")
        
        while self.tool_running:
            try:
                url = f"https://api.telegram.org/bot{self.config['telegram_bot_token']}/getUpdates"
                params = {"offset": self.last_update_id + 1, "timeout": 60}
                
                response = requests.get(url, params=params)
                if response.status_code == 200:
                    data = response.json()
                    if data["ok"] and data["result"]:
                        for update in data["result"]:
                            self.last_update_id = update["update_id"]
                            
                            if "message" in update and "text" in update["message"]:
                                message = update["message"]["text"]
                                chat_id = update["message"]["chat"]["id"]
                                
                                # Only respond to authorized chat
                                if str(chat_id) != self.config["telegram_chat_id"]:
                                    continue
                                
                                if message.startswith("/"):
                                    self.handle_telegram_command(message, chat_id)
            except Exception as e:
                print(Fore.RED + f"L·ªói Telegram bot: {str(e)}")
            
            time.sleep(1)

    def handle_telegram_command(self, command, chat_id):
        """Handle Telegram commands"""
        if command == "/start":
            self.send_telegram_message(
                "ü§ñ *Escape Master Bot ƒê√£ Kh·ªüi ƒê·ªông!*\nS·ª≠ d·ª•ng l·ªánh sau:\n"
                "/his - L·ªãch s·ª≠ c∆∞·ª£c\n"
                "/check - Ki·ªÉm tra k·∫øt qu·∫£ g·∫ßn nh·∫•t\n"
                "/info - Th√¥ng tin t√†i kho·∫£n\n"
                "/help - Tr·ª£ gi√∫p l·ªánh",
                chat_id
            )
        
        elif command == "/his":
            if not self.bet_history:
                self.send_telegram_message("üìù Ch∆∞a c√≥ l·ªãch s·ª≠ c∆∞·ª£c n√†o!", chat_id)
                return
            
            # Format history - limit to last 10 bets
            max_items = 10
            history_items = self.bet_history[-max_items:]
            
            # Create message
            history_text = "üìä *L·ªãch s·ª≠ c∆∞·ª£c g·∫ßn ƒë√¢y:*\n"
            for bet in history_items:
                status_emoji = "üü¢" if bet["status"] == "Th·∫Øng" else "üî¥" if bet["status"] == "Thua" else "üü°"
                history_text += f"{status_emoji} {bet['time']} - {bet['amount']} BUILD - {bet['room']} - {bet['status']}\n"
            
            self.send_telegram_message(history_text, chat_id)
        
        elif command == "/check":
            try:
                response = requests.get(self.api_10_van, headers=self.headers)
                if response.status_code == 200:
                    data = response.json()
                    if data.get("code") == 0:
                        issues = data.get("data", [])[:10]  # Get last 10 results
                        if issues:
                            room_mapping = {
                                1: "Nh√† Kho", 2: "Ph√≤ng H·ªçp", 3: "Ph√≤ng Gi√°m ƒê·ªëc",
                                4: "Ph√≤ng Tr√≤ Chuy·ªán", 5: "Ph√≤ng Gi√°m S√°t", 6: "VƒÉn Ph√≤ng",
                                7: "Ph√≤ng T√†i V·ª•", 8: "Ph√≤ng Nh√¢n S·ª±"
                            }
                            
                            result_text = "üîç *K·∫øt qu·∫£ g·∫ßn nh·∫•t:*\n"
                            for issue in issues:
                                room_name = room_mapping.get(issue["killed_room_id"], "Kh√¥ng x√°c ƒë·ªãnh")
                                time_str = datetime.fromtimestamp(issue["end_time"]).strftime("%H:%M:%S")
                                result_text += f"V√≤ng #{issue['issue_id']} - {room_name} - {time_str}\n"
                            
                            self.send_telegram_message(result_text, chat_id)
                        else:
                            self.send_telegram_message("Kh√¥ng c√≥ d·ªØ li·ªáu k·∫øt qu·∫£ g·∫ßn nh·∫•t", chat_id)
                    else:
                        self.send_telegram_message(f"L·ªói API: {data.get('message', 'Unknown')}", chat_id)
                else:
                    self.send_telegram_message(f"L·ªói k·∫øt n·ªëi: {response.status_code}", chat_id)
            except Exception as e:
                self.send_telegram_message(f"L·ªói: {str(e)}", chat_id)
        
        elif command == "/info":
            try:
                response = requests.get(self.url, headers=self.headers)
                if response.status_code == 200:
                    data = response.json()
                    if data.get("code") == 200:
                        username = data["data"]["username"]
                        balance = round(data["data"]["cwallet"]["ctoken_contribute"])
                        
                        info_text = (
                            "üë§ *Th√¥ng tin t√†i kho·∫£n:*\n"
                            f"T√™n: `{username}`\n"
                            f"UID: `{self.config['user_id']}`\n"
                            f"üí∞ S·ªë d∆∞: `{balance} BUILD`\n"
                            f"üìä Th·∫Øng/Thua: `{self.count_thang}/{self.count_thua}`\n"
                            f"üìà T·ªïng l·ªùi/l·ªó: `{self.tong_loi} BUILD`"
                        )
                        self.send_telegram_message(info_text, chat_id)
                    else:
                        self.send_telegram_message("Kh√¥ng l·∫•y ƒë∆∞·ª£c th√¥ng tin t√†i kho·∫£n", chat_id)
                else:
                    self.send_telegram_message(f"L·ªói k·∫øt n·ªëi: {response.status_code}", chat_id)
            except Exception as e:
                self.send_telegram_message(f"L·ªói: {str(e)}", chat_id)
        
        elif command == "/help":
            help_text = (
                "üÜò *Danh s√°ch l·ªánh:*\n"
                "/start - Kh·ªüi ƒë·ªông bot\n"
                "/his - Xem l·ªãch s·ª≠ c∆∞·ª£c (10 g·∫ßn nh·∫•t)\n"
                "/check - Ki·ªÉm tra k·∫øt qu·∫£ g·∫ßn nh·∫•t\n"
                "/info - Th√¥ng tin t√†i kho·∫£n\n"
                "/help - Tr·ª£ gi√∫p l·ªánh"
            )
            self.send_telegram_message(help_text, chat_id)
        
        else:
            self.send_telegram_message("‚ùå L·ªánh kh√¥ng h·ª£p l·ªá. G√µ /help ƒë·ªÉ xem danh s√°ch l·ªánh", chat_id)

    def run(self):
        self.display_header()
        print(Fore.YELLOW + f"S·ªë ti·ªÅn c∆∞·ª£c ban ƒë·∫ßu: {self.config['initial_bet']}")
        
        if self.config["stop_loss_enabled"]:
            print(Fore.RED + f"Stop Loss: -{self.config['stop_loss_amount']} | " + 
                  Fore.GREEN + f"Take Profit: +{self.config['take_profit_amount']}")
        else:
            print(Fore.YELLOW + "Stop Loss/Take Profit: T·∫ÆT")
        
        print(Fore.CYAN + f"H·ªá s·ªë g·∫•p: x{self.config['multipliers'][0]}, x{self.config['multipliers'][1]}, x{self.config['multipliers'][2]}")
        
        if self.config["telegram_bot_token"] and self.config["telegram_chat_id"]:
            print(Fore.GREEN + "Telegram bot: ƒê√É K√çCH HO·∫†T")
        else:
            print(Fore.YELLOW + "Telegram bot: CH∆ØA K√çCH HO·∫†T")
        
        print(Fore.CYAN + "-" * 70)
        
        self.login()
        
        try:
            while self.tool_running:
                self.lich_su()
                if not self.tool_running:
                    print(Fore.RED + "Tool ƒë√£ d·ª´ng do Stop Loss / Take Profit.")
                    break
                time.sleep(15)
        except KeyboardInterrupt:
            print(Fore.RED + "\nTool d·ª´ng b·ªüi ng∆∞·ªùi d√πng.")
            self.send_telegram_message("üõë *Tool ƒë√£ d·ª´ng th·ªß c√¥ng*")

if __name__ == "__main__":
    tool = EscapeMasterTool()
    tool.run()
